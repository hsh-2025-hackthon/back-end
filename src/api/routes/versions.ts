import { Router, Request, Response } from 'express';
import { requireAuth } from '../middleware/auth';
import { TripRepository } from '../../models/trip';
import { VersionService, ResolveConflictData } from '../../services/version-service';
import { z } from 'zod';

const router = Router();

// Request validation schemas
const CreateVersionSchema = z.object({
  description: z.string().optional()
});

const ResolveConflictSchema = z.object({
  resolutionStrategy: z.enum(['accept_mine', 'accept_theirs', 'merge_manual']),
  resolvedData: z.any().optional()
});

const CommitChangesSchema = z.object({
  changes: z.array(z.object({
    changeType: z.enum(['create', 'update', 'delete']),
    entityType: z.string(),
    entityId: z.string().optional(),
    fieldName: z.string().optional(),
    oldValue: z.any().optional(),
    newValue: z.any().optional(),
    changeDescription: z.string().optional()
  }))
});

/**
 * Get all versions for a trip
 */
router.get('/trips/:tripId/versions', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId } = req.params;
    const userId = req.user!.id;
    const limit = parseInt(req.query.limit as string) || 50;
    const offset = parseInt(req.query.offset as string) || 0;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const versions = await VersionService.getTripVersions(tripId, limit, offset);
    
    res.json({
      versions: versions.map(v => ({
        id: v.id,
        versionNumber: v.versionNumber,
        description: v.description,
        createdBy: v.createdBy,
        createdAt: v.createdAt,
        isAutoGenerated: v.isAutoGenerated,
        // Don't include full snapshot data in list view
        hasData: !!v.snapshotData
      })),
      totalVersions: versions.length,
      pagination: {
        limit,
        offset,
        hasMore: versions.length === limit
      }
    });

  } catch (error) {
    console.error('Error getting trip versions:', error);
    res.status(500).json({ 
      message: 'Failed to get trip versions',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Create a new version (snapshot) of a trip
 */
router.post('/trips/:tripId/versions', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId } = req.params;
    const userId = req.user!.id;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const validatedData = CreateVersionSchema.parse(req.body);
    const version = await VersionService.createVersion(tripId, userId, validatedData);

    res.status(201).json({
      success: true,
      version: {
        id: version.id,
        versionNumber: version.versionNumber,
        description: version.description,
        createdBy: version.createdBy,
        createdAt: version.createdAt,
        isAutoGenerated: version.isAutoGenerated
      },
      message: 'Version created successfully'
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        message: 'Invalid request data', 
        errors: error.issues 
      });
    }
    
    console.error('Error creating trip version:', error);
    res.status(500).json({ 
      message: 'Failed to create trip version',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Get a specific trip version
 */
router.get('/trips/:tripId/versions/:versionId', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId, versionId } = req.params;
    const userId = req.user!.id;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const version = await VersionService.getVersionById(tripId, versionId);
    
    if (!version) {
      return res.status(404).json({ message: 'Version not found' });
    }

    res.json({
      version: {
        id: version.id,
        versionNumber: version.versionNumber,
        description: version.description,
        snapshotData: version.snapshotData,
        createdBy: version.createdBy,
        createdAt: version.createdAt,
        isAutoGenerated: version.isAutoGenerated
      }
    });

  } catch (error) {
    console.error('Error getting trip version:', error);
    res.status(500).json({ 
      message: 'Failed to get trip version',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Revert a trip to a previous version
 */
router.post('/trips/:tripId/versions/:versionId/revert', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId, versionId } = req.params;
    const userId = req.user!.id;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    // Additional permission check - only trip owner or editors can revert
    const trip = await TripRepository.findById(tripId);
    const collaborators = await TripRepository.getCollaborators(tripId);
    const isOwner = trip?.createdBy === userId;
    const isEditor = collaborators.some(c => c.userId === userId && c.role === 'editor');
    
    if (!isOwner && !isEditor) {
      return res.status(403).json({ message: 'Insufficient permissions to revert trip' });
    }

    const result = await VersionService.revertTripToVersion(tripId, versionId, userId);

    if (result.success) {
      res.json({
        success: true,
        newVersionId: result.newVersionId,
        restoredTo: versionId,
        message: result.message
      });
    } else {
      res.status(409).json({
        success: false,
        message: result.message
      });
    }

  } catch (error) {
    console.error('Error reverting trip version:', error);
    res.status(500).json({ 
      message: 'Failed to revert trip version',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Get a log of changes for a trip
 */
router.get('/trips/:tripId/changes', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId } = req.params;
    const userId = req.user!.id;
    const since = req.query.since ? new Date(req.query.since as string) : undefined;
    const limit = parseInt(req.query.limit as string) || 20;
    const offset = parseInt(req.query.offset as string) || 0;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const changes = await VersionService.getTripChanges(tripId, since, limit, offset);

    res.json({
      changes,
      filters: {
        since: since?.toISOString(),
        limit,
        offset
      },
      pagination: {
        hasMore: changes.length === limit
      }
    });

  } catch (error) {
    console.error('Error getting trip changes:', error);
    res.status(500).json({ 
      message: 'Failed to get trip changes',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Commit pending changes for a trip
 */
router.post('/trips/:tripId/changes/commit', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId } = req.params;
    const userId = req.user!.id;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const validatedData = CommitChangesSchema.parse(req.body);
    const result = await VersionService.commitTripChanges(tripId, userId, validatedData.changes);

    if (result.success) {
      res.json({
        success: true,
        versionId: result.versionId,
        message: `Committed ${validatedData.changes.length} changes`,
        changeCount: validatedData.changes.length
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Failed to commit changes'
      });
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        message: 'Invalid request data', 
        errors: error.issues 
      });
    }
    
    console.error('Error committing trip changes:', error);
    res.status(500).json({ 
      message: 'Failed to commit trip changes',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Get all active conflicts for a trip
 */
router.get('/trips/:tripId/conflicts', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId } = req.params;
    const userId = req.user!.id;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const conflicts = await VersionService.getTripConflicts(tripId);

    res.json({
      conflicts,
      totalConflicts: conflicts.length,
      hasActiveConflicts: conflicts.length > 0
    });

  } catch (error) {
    console.error('Error getting trip conflicts:', error);
    res.status(500).json({ 
      message: 'Failed to get trip conflicts',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Get details of a specific conflict
 */
router.get('/trips/:tripId/conflicts/:conflictId', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId, conflictId } = req.params;
    const userId = req.user!.id;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const conflict = await VersionService.getConflictById(tripId, conflictId);
    
    if (!conflict) {
      return res.status(404).json({ message: 'Conflict not found' });
    }

    res.json({ conflict });

  } catch (error) {
    console.error('Error getting conflict details:', error);
    res.status(500).json({ 
      message: 'Failed to get conflict details',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Resolve a specific conflict
 */
router.post('/trips/:tripId/conflicts/:conflictId/resolve', requireAuth, async (req: Request, res: Response) => {
  try {
    const { tripId, conflictId } = req.params;
    const userId = req.user!.id;

    // Verify user has access to this trip
    const hasAccess = await TripRepository.checkTripAccess(tripId, userId);
    if (!hasAccess) {
      return res.status(403).json({ message: 'Access denied to this trip' });
    }

    const validatedData = ResolveConflictSchema.parse(req.body);
    const result = await VersionService.resolveConflict(tripId, conflictId, userId, validatedData as ResolveConflictData);

    if (result.success) {
      res.json({
        success: true,
        message: result.message,
        resolutionStrategy: validatedData.resolutionStrategy
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.message
      });
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        message: 'Invalid request data', 
        errors: error.issues 
      });
    }
    
    console.error('Error resolving conflict:', error);
    res.status(500).json({ 
      message: 'Failed to resolve conflict',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

export default router;
