import { getDatabase } from '../config/database';

export interface TripVersion {
  id: string;
  tripId: string;
  versionNumber: number;
  description?: string;
  snapshotData: any;
  createdBy: string;
  createdAt: Date;
  isAutoGenerated: boolean;
}

export interface TripChange {
  id: string;
  tripId: string;
  versionId?: string;
  changeType: 'create' | 'update' | 'delete';
  entityType: string;
  entityId?: string;
  fieldName?: string;
  oldValue?: any;
  newValue?: any;
  changeDescription?: string;
  createdBy: string;
  createdAt: Date;
  operationId?: string;
}

export interface TripConflict {
  id: string;
  tripId: string;
  conflictType: 'semantic' | 'structural' | 'data';
  entityType: string;
  entityId?: string;
  conflictingData: any;
  involvedUsers: string[];
  status: 'active' | 'resolved' | 'ignored';
  resolutionStrategy?: 'accept_mine' | 'accept_theirs' | 'merge_manual';
  resolvedData?: any;
  resolvedBy?: string;
  resolvedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateVersionData {
  description?: string;
}

export interface ResolveConflictData {
  resolutionStrategy: 'accept_mine' | 'accept_theirs' | 'merge_manual';
  resolvedData?: any;
}

export class VersionService {
  // Trip Versions
  static async getTripVersions(tripId: string, limit: number = 50, offset: number = 0): Promise<TripVersion[]> {
    const db = getDatabase();
    const query = `
      SELECT 
        id, trip_id as "tripId", version_number as "versionNumber", 
        description, snapshot_data as "snapshotData", created_by as "createdBy", 
        created_at as "createdAt", is_auto_generated as "isAutoGenerated"
      FROM trip_versions 
      WHERE trip_id = $1
      ORDER BY version_number DESC
      LIMIT $2 OFFSET $3
    `;
    
    const result = await db.query(query, [tripId, limit, offset]);
    return result.rows;
  }

  static async getVersionById(tripId: string, versionId: string): Promise<TripVersion | null> {
    const db = getDatabase();
    const query = `
      SELECT 
        id, trip_id as "tripId", version_number as "versionNumber", 
        description, snapshot_data as "snapshotData", created_by as "createdBy", 
        created_at as "createdAt", is_auto_generated as "isAutoGenerated"
      FROM trip_versions 
      WHERE trip_id = $1 AND id = $2
    `;
    
    const result = await db.query(query, [tripId, versionId]);
    return result.rows[0] || null;
  }

  static async createVersion(tripId: string, userId: string, data: CreateVersionData): Promise<TripVersion> {
    const db = getDatabase();
    
    // Get next version number
    const versionQuery = `
      SELECT COALESCE(MAX(version_number), 0) + 1 as next_version
      FROM trip_versions WHERE trip_id = $1
    `;
    const versionResult = await db.query(versionQuery, [tripId]);
    const nextVersion = versionResult.rows[0].next_version;

    // Get current trip data with related entities
    const tripDataQuery = `
      WITH trip_data AS (
        SELECT row_to_json(t.*) as trip
        FROM trips t WHERE t.id = $1
      ),
      destinations_data AS (
        SELECT COALESCE(jsonb_agg(row_to_json(d)), '[]'::jsonb) as destinations
        FROM destinations d WHERE d.trip_id = $1
      ),
      collaborators_data AS (
        SELECT COALESCE(jsonb_agg(row_to_json(tc)), '[]'::jsonb) as collaborators
        FROM trip_collaborators tc WHERE tc.trip_id = $1
      )
      SELECT jsonb_build_object(
        'trip', (SELECT trip FROM trip_data),
        'destinations', (SELECT destinations FROM destinations_data),
        'collaborators', (SELECT collaborators FROM collaborators_data)
      ) as snapshot_data
    `;
    
    const snapshotResult = await db.query(tripDataQuery, [tripId]);
    const snapshotData = snapshotResult.rows[0].snapshot_data;

    // Create version
    const insertQuery = `
      INSERT INTO trip_versions (
        trip_id, version_number, description, snapshot_data, created_by, is_auto_generated
      ) VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING 
        id, trip_id as "tripId", version_number as "versionNumber", 
        description, snapshot_data as "snapshotData", created_by as "createdBy", 
        created_at as "createdAt", is_auto_generated as "isAutoGenerated"
    `;
    
    const result = await db.query(insertQuery, [
      tripId, 
      nextVersion, 
      data.description || `Manual snapshot ${nextVersion}`, 
      snapshotData, 
      userId, 
      false
    ]);
    
    return result.rows[0];
  }

  static async revertTripToVersion(tripId: string, versionId: string, userId: string): Promise<{ success: boolean; newVersionId?: string; message: string }> {
    const db = getDatabase();
    
    try {
      await db.query('BEGIN');
      
      // Get the version to revert to
      const version = await this.getVersionById(tripId, versionId);
      if (!version) {
        await db.query('ROLLBACK');
        return { success: false, message: 'Version not found' };
      }

      const snapshot = version.snapshotData;
      
      // Update main trip record
      if (snapshot.trip) {
        const updateTripQuery = `
          UPDATE trips SET 
            title = $1, description = $2, start_date = $3, end_date = $4,
            destination = $5, budget = $6, currency = $7, status = $8,
            updated_at = NOW()
          WHERE id = $9
        `;
        
        const trip = snapshot.trip;
        await db.query(updateTripQuery, [
          trip.title, trip.description, trip.start_date, trip.end_date,
          trip.destination, trip.budget, trip.currency, trip.status, tripId
        ]);
      }

      // Clear and restore destinations
      await db.query('DELETE FROM destinations WHERE trip_id = $1', [tripId]);
      
      if (snapshot.destinations && Array.isArray(snapshot.destinations)) {
        for (const dest of snapshot.destinations) {
          const insertDestQuery = `
            INSERT INTO destinations (
              id, trip_id, name, country, city, latitude, longitude, 
              description, order_index, created_at, updated_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
          `;
          
          await db.query(insertDestQuery, [
            dest.id, tripId, dest.name, dest.country, dest.city,
            dest.latitude, dest.longitude, dest.description, dest.order_index,
            dest.created_at, dest.updated_at
          ]);
        }
      }

      // Create a new version to record this revert
      const revertVersion = await this.createVersion(tripId, userId, {
        description: `Reverted to version ${version.versionNumber}`
      });

      await db.query('COMMIT');
      
      return { 
        success: true, 
        newVersionId: revertVersion.id,
        message: `Successfully reverted to version ${version.versionNumber}` 
      };
      
    } catch (error) {
      await db.query('ROLLBACK');
      console.error('Error reverting trip version:', error);
      return { 
        success: false, 
        message: error instanceof Error ? error.message : 'Unknown error during revert' 
      };
    }
  }

  // Trip Changes
  static async getTripChanges(
    tripId: string, 
    since?: Date, 
    limit: number = 20, 
    offset: number = 0
  ): Promise<TripChange[]> {
    const db = getDatabase();
    let query = `
      SELECT 
        id, trip_id as "tripId", version_id as "versionId", change_type as "changeType",
        entity_type as "entityType", entity_id as "entityId", field_name as "fieldName",
        old_value as "oldValue", new_value as "newValue", change_description as "changeDescription",
        created_by as "createdBy", created_at as "createdAt", operation_id as "operationId"
      FROM trip_changes 
      WHERE trip_id = $1
    `;
    
    const params: any[] = [tripId];
    
    if (since) {
      query += ` AND created_at >= $${params.length + 1}`;
      params.push(since);
    }
    
    query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);
    
    const result = await db.query(query, params);
    return result.rows;
  }

  static async commitTripChanges(tripId: string, userId: string, changes: any[]): Promise<{ success: boolean; versionId?: string }> {
    const db = getDatabase();
    
    try {
      await db.query('BEGIN');
      
      const operationId = `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Log all changes
      for (const change of changes) {
        const insertQuery = `
          INSERT INTO trip_changes (
            trip_id, change_type, entity_type, entity_id, field_name,
            old_value, new_value, change_description, created_by, operation_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        `;
        
        await db.query(insertQuery, [
          tripId, change.changeType, change.entityType, change.entityId,
          change.fieldName, change.oldValue, change.newValue, 
          change.changeDescription, userId, operationId
        ]);
      }
      
      // Create a version snapshot for this commit
      const version = await this.createVersion(tripId, userId, {
        description: `Commit: ${changes.length} changes`
      });
      
      await db.query('COMMIT');
      
      return { success: true, versionId: version.id };
      
    } catch (error) {
      await db.query('ROLLBACK');
      console.error('Error committing trip changes:', error);
      return { success: false };
    }
  }

  // Conflict Resolution
  static async getTripConflicts(tripId: string): Promise<TripConflict[]> {
    const db = getDatabase();
    const query = `
      SELECT 
        id, trip_id as "tripId", conflict_type as "conflictType",
        entity_type as "entityType", entity_id as "entityId", 
        conflicting_data as "conflictingData", involved_users as "involvedUsers",
        status, resolution_strategy as "resolutionStrategy", 
        resolved_data as "resolvedData", resolved_by as "resolvedBy",
        resolved_at as "resolvedAt", created_at as "createdAt", updated_at as "updatedAt"
      FROM trip_conflicts 
      WHERE trip_id = $1 AND status = 'active'
      ORDER BY created_at DESC
    `;
    
    const result = await db.query(query, [tripId]);
    return result.rows;
  }

  static async getConflictById(tripId: string, conflictId: string): Promise<TripConflict | null> {
    const db = getDatabase();
    const query = `
      SELECT 
        id, trip_id as "tripId", conflict_type as "conflictType",
        entity_type as "entityType", entity_id as "entityId", 
        conflicting_data as "conflictingData", involved_users as "involvedUsers",
        status, resolution_strategy as "resolutionStrategy", 
        resolved_data as "resolvedData", resolved_by as "resolvedBy",
        resolved_at as "resolvedAt", created_at as "createdAt", updated_at as "updatedAt"
      FROM trip_conflicts 
      WHERE trip_id = $1 AND id = $2
    `;
    
    const result = await db.query(query, [tripId, conflictId]);
    return result.rows[0] || null;
  }

  static async resolveConflict(
    tripId: string, 
    conflictId: string, 
    userId: string, 
    resolution: ResolveConflictData
  ): Promise<{ success: boolean; message: string }> {
    const db = getDatabase();
    
    try {
      const updateQuery = `
        UPDATE trip_conflicts SET 
          status = 'resolved',
          resolution_strategy = $1,
          resolved_data = $2,
          resolved_by = $3,
          resolved_at = NOW(),
          updated_at = NOW()
        WHERE trip_id = $4 AND id = $5
        RETURNING id
      `;
      
      const result = await db.query(updateQuery, [
        resolution.resolutionStrategy,
        resolution.resolvedData || null,
        userId,
        tripId,
        conflictId
      ]);
      
      if (result.rows.length === 0) {
        return { success: false, message: 'Conflict not found' };
      }
      
      return { success: true, message: 'Conflict resolved successfully' };
      
    } catch (error) {
      console.error('Error resolving conflict:', error);
      return { 
        success: false, 
        message: error instanceof Error ? error.message : 'Unknown error during conflict resolution' 
      };
    }
  }

  // Helper method to detect and create conflicts
  static async detectAndCreateConflict(
    tripId: string,
    conflictType: 'semantic' | 'structural' | 'data',
    entityType: string,
    entityId: string,
    conflictingData: any,
    involvedUsers: string[]
  ): Promise<string> {
    const db = getDatabase();
    
    const insertQuery = `
      INSERT INTO trip_conflicts (
        trip_id, conflict_type, entity_type, entity_id, 
        conflicting_data, involved_users
      ) VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id
    `;
    
    const result = await db.query(insertQuery, [
      tripId, conflictType, entityType, entityId, 
      conflictingData, involvedUsers
    ]);
    
    return result.rows[0].id;
  }
}
